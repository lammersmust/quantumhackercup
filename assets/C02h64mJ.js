import{_ as r}from"./BqdexuIt.js";import{_ as i}from"./CsJap-5M.js";import{_ as a,n as u,w as t,u as d,o as m,a as e,b as p,P as h}from"./DIdaT3oj.js";import"./CFaCMZmV.js";const g={};function c(o,n){const l=r,s=i;return m(),u(s,{title:"Problem D: Hidden Cipher",points:("PROBLEMS_POINTS"in o?o.PROBLEMS_POINTS:d(h)).D},{default:t(()=>[n[2]||(n[2]=e("p",null,' You have encountered a classic cipher where letters are substituted with numbers: A = 1, B = 2, ..., Z = 26. For instance, the word "CODE" would be encoded as 3 15 4 5. ',-1)),n[3]||(n[3]=e("p",null," You receive an encoded string of digits, E, but all spaces have been removed, and some digits may have been corrupted and are represented by question marks (?). ",-1)),n[4]||(n[4]=e("p",null,` Your task is to restore the corrupted string by replacing each '?' with a digit (0-9), and then split the uncorrupted string into a sequence of numbers between 1 and 26 inclusive. For example, the corrupted string "?35?01" could be restored to "135201". This uncorrupted string can be split into "13 5 20 1", which decodes to "CETU". It can also be split into "1 3 5 20 1", decoding to "ACEUA". Note that leading zeros are invalid, so splits like "13 5 2 01" are not acceptable because "01" is not a valid number in this context. `,-1)),n[5]||(n[5]=e("p",null," Given the corrupted encoded string, determine the uncorrupted version that allows for the maximum number of possible decoded messages, and find out how many such decodings exist. ",-1)),n[6]||(n[6]=e("p",null," Since there may be multiple uncorrupted strings yielding the same maximum number of decodings, output the Kth lexicographically largest among them. Output the number of possible decoded messages that this uncorrupted string can produce, modulo 998,244,353. ",-1)),n[7]||(n[7]=e("h2",null,"Constraints",-1)),n[8]||(n[8]=e("p",null,[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"1"),e("mo",null,"≤"),e("mi",null,"T"),e("mo",null,"≤"),e("mn",null,"85")]),e("annotation",{encoding:"application/x-tex"},"1 \\leq T \\leq 85")])]),e("br"),e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"1"),e("mo",null,"≤"),e("mi",{mathvariant:"normal"},"∣"),e("mi",null,"E"),e("mi",{mathvariant:"normal"},"∣"),e("mo",null,"≤"),e("mn",null,"100"),e("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),e("mn",null,"000")]),e("annotation",{encoding:"application/x-tex"},"1 \\leq |E| \\leq 100{,}000")])]),e("br"),e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mn",null,"1"),e("mo",null,"≤"),e("mi",null,"K"),e("mo",null,"≤"),e("mn",null,"1"),e("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),e("mn",null,"000"),e("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),e("mn",null,"000")]),e("annotation",{encoding:"application/x-tex"},"1 \\leq K \\leq 1{,}000{,}000")])])],-1)),n[9]||(n[9]=e("ul",null,[e("li",null,"Each character in E is either a digit (0-9) or a question mark '?'."),e("li",null," K will not exceed the number of uncorrupted strings that allow for the maximum number of decodings. "),e("li",null,"There is always at least one valid uncorrupted version of E that can be properly decoded.")],-1)),n[10]||(n[10]=e("p",null,"The total length of all E across all test cases does not exceed 400,000.",-1)),n[11]||(n[11]=e("h2",null,"Input Format",-1)),n[12]||(n[12]=e("p",null," The input starts with an integer T, the number of test cases. Each test case consists of a single line containing the corrupted string E followed by the integer K. ",-1)),n[13]||(n[13]=e("h2",null,"Output Format",-1)),n[14]||(n[14]=e("p",null,' For each test case, output "Case #i: " followed by the Kth lexicographically largest uncorrupted encoded string among those that yield the maximum number of decodings, and then the number of possible decodings modulo 998,244,353. ',-1)),n[15]||(n[15]=e("h2",null,"Sample Explanation",-1)),n[16]||(n[16]=e("p",null,' In the first test case, possible uncorrupted strings include "282", which can only be decoded in 1 way. Other uncorrupted strings like "212" can be decoded into 3 different messages, which is the maximum possible. The uncorrupted strings that decode into 3 ways are ["222", "212", "122", "112"]. The third largest lexicographically is "122". ',-1)),n[17]||(n[17]=e("p",null," In the second test case, the string is already uncorrupted and can be decoded in 2 different ways. ",-1)),n[18]||(n[18]=e("p",null,' In the third test case, to maximize the number of decodings (which is 2), the two uncorrupted strings are "235" and "135". ',-1)),n[19]||(n[19]=e("p",null,' In the fourth test case, the two options are "120" and "110", each of which can be decoded in only 1 way. ',-1)),n[20]||(n[20]=e("p",null," In the fifth test case, there are no corrupted digits, and the encoded string can be decoded in 5 different ways. ",-1)),p(l,null,{input:t(()=>n[0]||(n[0]=[e("pre",null,`6
??2 3
135201 1
?35 2
1?0 2
1122 1
3???????????????????3 1337`,-1)])),output:t(()=>n[1]||(n[1]=[e("pre",null,`Case #1: 122 3
Case #2: 135201 2
Case #3: 135 2
Case #4: 110 1
Case #5: 1122 5
Case #6: 322222222121221112223 10946`,-1)])),_:1})]),_:1},8,["points"])}const y=a(g,[["render",c]]);export{y as default};
