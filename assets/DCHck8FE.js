import{_ as r}from"./CsXgw3Wm.js";import{_ as i}from"./EKwLFbPh.js";import{_ as a,n as u,w as n,u as d,o as m,a as t,b as p,P as h}from"./BllL7jBv.js";import"./C1mGQBNe.js";const g={};function b(o,e){const s=r,l=i;return m(),u(l,{title:"Problem D: Substitution Cipher",points:("PROBLEMS_POINTS"in o?o.PROBLEMS_POINTS:d(h)).D},{default:n(()=>[e[2]||(e[2]=t("p",null," You’ve probably seen the most classic substitution cipher, where 1 = A, 2 = B, and so on. Under this scheme, a string like META would be encoded as 13 5 20 1. ",-1)),e[3]||(e[3]=t("p",null," You’ve just received an encoded string of digits, E, but unfortunately all of the spaces have been removed and some (possibly 0) of the digits have become corrupted (represented as question marks). ",-1)),e[4]||(e[4]=t("p",null," You must first “uncorrupt” the string by replacing each instance of ? with a digit and then splitting the uncorrupted string into a series of numbers that are all between 1 and 26 inclusive. For example, the string ?35?01 can be uncorrupted to 135201. That uncorrupted string can be split into 13 5 20 1 as above, but also 1 3 5 20 1, which decodes to ACETA. Note that leading zeros are not valid, so 13 5 2 01 is not a valid way to split the uncorrupted string, so this uncorrupted string cannot be decoded into MEBA. ",-1)),e[5]||(e[5]=t("p",null," Given a corrupted encoded string, what uncorrupted encoded string has the largest number of possible strings that it could decode into, and how many decoded strings is that? ",-1)),e[6]||(e[6]=t("p",null," As there may be multiple uncorrupted encoded strings that share the same maximum answer, output the lexicographically Kth largest among them. Output the number of decoded strings that this uncorrupted encoded string can decode into modulo 998,244,353. ",-1)),e[7]||(e[7]=t("h2",null,"Constraints",-1)),e[8]||(e[8]=t("p",null,[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"1"),t("mo",null,"≤"),t("mi",null,"T"),t("mo",null,"≤"),t("mn",null,"85")]),t("annotation",{encoding:"application/x-tex"},"1 \\leq T \\leq 85")])]),t("br"),t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"1"),t("mo",null,"≤"),t("mi",{mathvariant:"normal"},"∣"),t("mi",null,"E"),t("mi",{mathvariant:"normal"},"∣"),t("mo",null,"≤"),t("mn",null,"100"),t("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),t("mn",null,"000")]),t("annotation",{encoding:"application/x-tex"},"1 \\leq |E| \\leq 100{,}000")])]),t("br"),t("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[t("semantics",null,[t("mrow",null,[t("mn",null,"1"),t("mo",null,"≤"),t("mi",null,"K"),t("mo",null,"≤"),t("mn",null,"1"),t("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),t("mn",null,"000"),t("mo",{separator:"true",lspace:"0em",rspace:"0em"},","),t("mn",null,"000")]),t("annotation",{encoding:"application/x-tex"},"1 \\leq K \\leq 1{,}000{,}000")])])],-1)),e[9]||(e[9]=t("ul",null,[t("li",null,"Every character in E is either a digit or a question mark."),t("li",null," K will never be larger than the number of uncorrupted strings that have the most possible decoded strings. "),t("li",null,"There will always be some uncorrupted version of E that can be properly decoded.")],-1)),e[10]||(e[10]=t("p",null,"The sum of ∣E∣ across all test cases is at most 400,000.",-1)),e[11]||(e[11]=t("h2",null,"Input Format",-1)),e[12]||(e[12]=t("p",null," Input begins with an integer T, the number of test cases. Each case is a single line that contains the string E followed by the integer K. ",-1)),e[13]||(e[13]=t("h2",null,"Output Format",-1)),e[14]||(e[14]=t("p",null,' For the ith test case, print "Case #i: " followed by the lexicographically Kth-largest uncorrupted encoded string amongst all possible uncorrupted encoded strings that can be decoded into the maximum number of decoded strings, followed by what that maximum is, modulo 998,244,353. ',-1)),e[15]||(e[15]=t("h2",null,"Sample Explanation",-1)),e[16]||(e[16]=t("p",null," In the first case, possible uncorrupted strings include 282, but strings like that can only decode to 1 string, whereas other strings like 212 can be decoded into 3 different strings, the maximum possible. The uncorrupted strings that can be decoded into 3 different strings are [222, 212, 122, 112], so 122 is the lexicographically third-largest. ",-1)),e[17]||(e[17]=t("p",null," The second case is described above. The string has no corrupted digits and can be decoded into 2 different strings. ",-1)),e[18]||(e[18]=t("p",null," In the third case, to maximize the number of possible decodings for a given uncorrupted string, which is 2, the two options are 235 and 135. ",-1)),e[19]||(e[19]=t("p",null," In the fourth case, the two options are 120 and 110, each of which decode to just 1 string. ",-1)),e[20]||(e[20]=t("p",null," In the fifth case, there are no uncorrupted digits and the encoded string can be decoded into 5 different strings: KV, KBB, ANB, AAV, AABB. ",-1)),p(s,null,{input:n(()=>e[0]||(e[0]=[t("pre",null,`6
??2 3
135201 1
?35 2
1?0 2
1122 1
3???????????????????3 1337`,-1)])),output:n(()=>e[1]||(e[1]=[t("pre",null,`Case #1: 122 3
Case #2: 135201 2
Case #3: 135 2
Case #4: 110 1
Case #5: 1122 5
Case #6: 322222222121221112223 10946`,-1)])),_:1})]),_:1},8,["points"])}const v=a(g,[["render",b]]);export{v as default};
